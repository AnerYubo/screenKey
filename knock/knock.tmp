package knock

import (
	"fmt"
	"net"
	"strings"
	"time"

	"screenKey/sqlite"
)

type KnockData struct {
	ID         int64  `json:"id"`
	Host       string `json:"host"`
	TargetPort int    `json:"targetPort"`
	KnockPorts []int  `json:"knockPorts"`
	Remark     string `json:"remark"`
}

// åˆ›å»ºæ–°çš„æ•²é—¨é…ç½®
func CreateKnock(data KnockData) error {
	portsStr := portsToString(data.KnockPorts)
	_, err := sqlite.DB.Insert("knocks", map[string]interface{}{
		"host":        data.Host,
		"target_port": data.TargetPort,
		"knock_ports": portsStr,
		"remark":      data.Remark,
	})
	return err
}

// è·å–æ‰€æœ‰é…ç½®å¹¶æ£€æµ‹ç«¯å£çŠ¶æ€
func ListKnocks() ([]KnockData, error) {
	rows, err := sqlite.DB.GetAll("SELECT * FROM knocks;")
	if err != nil {
		return nil, err
	}

	list := make([]KnockData, len(rows))
	for i, row := range rows {
		list[i] = KnockData{
			ID:         row["id"].(int64),
			Host:       row["host"].(string),
			TargetPort: int(row["target_port"].(int64)),
			KnockPorts: parsePorts(row["knock_ports"].(string)),
			Remark:     row["remark"].(string),
		}
	}

	return list, nil
}

// åˆ é™¤é…ç½®
func DeleteKnock(id int64) error {
	_, err := sqlite.DB.Exec("DELETE FROM knocks WHERE id = ?;", id)
	return err
}

// æ›´æ–°é…ç½®
func UpdateKnock(id int64, data KnockData) error {
	portsStr := portsToString(data.KnockPorts)
	_, err := sqlite.DB.Exec(`UPDATE knocks SET host=?, target_port=?, knock_ports=?, remark=? WHERE id=?`,
		data.Host, data.TargetPort, portsStr, data.Remark, id)
	return err
}

// æ•²é—¨é€»è¾‘ï¼ˆè¿™é‡Œåªæ˜¯æ‰“å°ï¼‰
func KnockTarget(data KnockData) error {
	fmt.Printf("ğŸ” å¼€å§‹æ•²é—¨ %s -> %v -> %d\n", data.Host, data.KnockPorts, data.TargetPort)

	// å…ˆè§£æåŸŸåï¼Œæ‹¿ IP
	ips, err := net.LookupIP(data.Host)
	if err != nil || len(ips) == 0 {
		return fmt.Errorf("DNSè§£æå¤±è´¥ %s: %v", data.Host, err)
	}
	ipStr := ips[0].String()
	fmt.Printf("ğŸ” è§£æåˆ°IP: %s\n", ipStr)

	// æ•² knockPortsï¼ˆé¡ºåºé‡è¦ï¼‰
	for _, port := range data.KnockPorts {
		address := fmt.Sprintf("%s:%d", ipStr, port)
		conn, err := net.DialTimeout("tcp", address, 1*time.Millisecond) // è¶…æ—¶200ms
		if err != nil {
			fmt.Printf("âš ï¸ æ•²é—¨ç«¯å£å¤±è´¥ [%s]: %v\n", address, err)
		} else {
			fmt.Printf("âœ… æ•²é—¨ç«¯å£æˆåŠŸ [%s]\n", address)
			conn.Close()
		}
		time.Sleep(200 * time.Millisecond) // æ¯æ¬¡æ•²é—¨é—´éš”
	}
	time.Sleep(1 * time.Second) // æ•²é—¨ç»“æŸéœ€è¦é—´éš”

	// æœ€ç»ˆè¿æ¥ç›®æ ‡ç«¯å£ï¼ŒéªŒè¯æ˜¯å¦å¼€æ”¾
	targetAddr := fmt.Sprintf("%s:%d", ipStr, data.TargetPort)
	conn, err := net.DialTimeout("tcp", targetAddr, 1*time.Second)
	if err != nil {
		fmt.Printf("âŒ ç›®æ ‡ç«¯å£è¿æ¥å¤±è´¥ [%s]: %v\n", targetAddr, err)
		return err
	}
	defer conn.Close()

	fmt.Printf("ğŸ‰ æ•²é—¨æˆåŠŸï¼Œç›®æ ‡ç«¯å£ [%s] å·²å¼€æ”¾ï¼\n", targetAddr)
	return nil
}

// æ£€æŸ¥ç«¯å£æ˜¯å¦å¼€æ”¾
func CheckPortOpen(data KnockData) bool {
	fmt.Printf(" ç«¯å£æ£€æµ‹ä¸­%s: %v\n", address)
	address := fmt.Sprintf("%s:%d", data.Host, data.TargetPort)
	conn, err := net.DialTimeout("tcp", address, 1*time.Second)
	if err != nil {
		fmt.Printf("âŒ ç«¯å£æ£€æµ‹å¤±è´¥ %s: %v\n", address, err)
		return false
	}
	conn.Close()

	return true
}

// ç«¯å£æ•°ç»„è½¬å­—ç¬¦ä¸²
func portsToString(ports []int) string {
	var parts []string
	for _, p := range ports {
		parts = append(parts, fmt.Sprintf("%d", p))
	}
	return strings.Join(parts, ",")
}

// å­—ç¬¦ä¸²è½¬ç«¯å£æ•°ç»„
func parsePorts(s string) []int {
	var ports []int
	for _, str := range SplitAndTrim(s, ",") {
		var p int
		if _, err := fmt.Sscanf(str, "%d", &p); err == nil {
			ports = append(ports, p)
		}
	}
	return ports
}

// å­—ç¬¦ä¸²åˆ‡å‰²å¹¶æ¸…æ´—
func SplitAndTrim(s string, sep string) []string {
	var result []string
	for _, part := range strings.Split(s, sep) {
		part = strings.TrimSpace(part)
		if part != "" {
			result = append(result, part)
		}
	}
	return result
}
